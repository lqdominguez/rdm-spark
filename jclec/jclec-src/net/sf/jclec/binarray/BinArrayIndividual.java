package net.sf.jclec.binarray;

import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;

import net.sf.jclec.base.AbstractIndividual;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Individual with a byte array as genotype.
 *  
 * @author Sebastian Ventura
 */

@SuppressWarnings("deprecation")
public class BinArrayIndividual extends AbstractIndividual<byte[]> 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by eclipse */
	
	private static final long serialVersionUID = 6227386750669278917L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor
	 */
	
	public BinArrayIndividual() 
	{
		super();
	}

	/**
	 * Constructor that sets individual genotype.
	 * 
	 * @param genotype Individual genotype
	 */
	
	public BinArrayIndividual(byte[] genotype) 
	{
		super(genotype);
	}

	/**
	 * Constructor that sets individual genotype and fitness.
	 * 
	 * @param genotype Individual genotype
	 * @param fitness  Individual fitness
	 */
	
	public BinArrayIndividual(byte[] genotype, IFitness fitness) 
	{
		super(genotype, fitness);
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
		
	// IIndividual methods
		
	/**
	 * {@inheritDoc}
	 */
		
	public IIndividual copy() 
	{
		// Genotype length
		int gl = genotype.length;
		// Allocate a copy of genotype
		byte [] gother = new byte[genotype.length];
		// Copy genotype
		System.arraycopy(genotype, 0, gother, 0, gl);
		// Create new individuals, then return it
		if (fitness != null) {
			return new BinArrayIndividual(gother, fitness.copy());			
		}
		else {
			return new BinArrayIndividual(gother);			
		}
	}

	/**
	 * BinArrayIndividual uses the Hamming distance for setting 
	 * differences between individuals - at genotype level.
	 * 
	 * {@inheritDoc}
	 */
	
	public double distance(IIndividual other) 
	{
		// Other genotype
		byte [] gother = ((BinArrayIndividual) other).genotype;
		// Setting Hamming distance
		int distance = 0;
		int gl = genotype.length;
		for (int i=0; i<gl; i++) {
			if (genotype[i] != gother[i])
				distance++;
		}	
		// Returns hamming distance
		return (double) distance;
	}

	// java.lang.Object methods
	
	/**
	 * {@inheritDoc}
	 */
	
	@Override
	public boolean equals(Object other) 
	{
		if (other instanceof BinArrayIndividual) {
			BinArrayIndividual baother = (BinArrayIndividual) other;
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(genotype, baother.genotype);
			eb.append(fitness, baother.fitness);
			return eb.isEquals();
		}
		else {
			return false;
		}
	}
}
