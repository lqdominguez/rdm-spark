package net.sf.jclec.binarray.rec;

import net.sf.jclec.IConfigure;

import net.sf.jclec.binarray.BinArrayIndividual;
import net.sf.jclec.binarray.BinArrayRecombinator;

import org.apache.commons.configuration.Configuration;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Uniform crossover for BinArrayIndividual and its subclasses
 * 
 * @author Sebastian Ventura
 */

public class UniformCrossover extends BinArrayRecombinator implements IConfigure
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/**	Generated by eclipse */
	
	private static final long serialVersionUID = 3258697598016829492L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
	
	/** Crossover probability */
	
	private double locusCrossoverProb;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor
	 */
	
	public UniformCrossover() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// Setting and getting properties

	/**
	 * @return Returns the locus crossover probability
	 */
	
	public final double getLocusCrossoverProb() 
	{
		return locusCrossoverProb;
	}
	
	/**
	 * @param crossProb New locus crossover probability
	 */
	
	public final void setLocusCrossoverProb(double crossProb) 
	{
		this.locusCrossoverProb = crossProb;
	}
	
	// IConfigure interface

	/**
	 * Configuration method.
	 * 
	 * Configuration parameters for UniformCrossover are:
	 * 
	 * <ul>
	 * <li>
	 * <code>[@evaluate]: boolean (default = true)</code></p> 
	 * If this parameter is set to <code>true</true> individuals will
	 * be evaluated after its creation. 
	 * </li>
	 * <li>
	 * <code>[@locus-crossover-prob]: double (default = 0.5)</code></p>
	 * Locus crossover probability.  
	 * </li>
	 * <li>
	 * <code>random-generator: complex</code></p>
	 * Random generator used in individuals mutation.  
	 * <ul>
	 * 		<li>
	 * 		<code>random-generator[@type] String (default 'net.sf.jclec.random.Ranecu')</code>
	 * 		</li>
	 * </ul> 
	 * </li>
	 * </ul>
	 */

	public void configure(Configuration configuration) 
	{
		// Get the 'locus-crossover-prob' property
		double locusCrossoverProb = configuration.getDouble("[@locus-crossover-prob]", 0.5);
		setLocusCrossoverProb(locusCrossoverProb);
	}
	
	// java.lang.Object methods
	
	/**
	 * {@inheritDoc}
	 */
	
	@Override
	public boolean equals(Object other)
	{
		if (other instanceof UniformCrossover) {
			// Type conversion
			UniformCrossover cother = (UniformCrossover) other;
			// Equals Buildre
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(locusCrossoverProb, cother.locusCrossoverProb);
			// Returns 
			return eb.isEquals();
		}
		else {
			return false;
		}
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	// AbstractRecombinator methods
	
	/**
	 * {@inheritDoc}
	 */
	
	@Override
	protected void recombineNext() 
	{
		// Genotype length
		int gl = species.getGenotypeLength();
		// Parents conversion
		BinArrayIndividual p0 = 
			(BinArrayIndividual) parentsBuffer.get(parentsCounter);
		BinArrayIndividual p1 = 
			(BinArrayIndividual) parentsBuffer.get(parentsCounter+1);
		// Parents genotypes
		byte [] p0_genome = p0.getGenotype();
		byte [] p1_genome = p1.getGenotype();
		// Creating sons genotypes
		byte [] s0_genome = new byte[gl];
		byte [] s1_genome = new byte[gl];
		// Building sons
		for (int i=0; i<gl; i++) {
			if (randgen.coin(locusCrossoverProb)) {
				s0_genome[i] = p1_genome[i];
				s1_genome[i] = p0_genome[i];
			}
			else {
				s0_genome[i] = p0_genome[i];
				s1_genome[i] = p1_genome[i];
			}
		}
		// Put sons in sincell
		sonsBuffer.add(species.createIndividual(s0_genome));
		sonsBuffer.add(species.createIndividual(s1_genome));	
	}
	
	/*
	 * El mtodo realiza las siguientes acciones:
	 * 
	 * 1) Crea los genotipos de los hijos.
	 * 2) Para cada uno de los loci del individuo, generamos un valor
	 *    aleatorio entre 0 y 1. Si el valor no excede locusMutationProb,
	 *    se intercambian los locus de los padres en el hijo. Si no, 
	 *    persiste el valor del padre en el hijo correspondiente.
	 */
}