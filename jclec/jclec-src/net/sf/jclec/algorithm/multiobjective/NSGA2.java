package net.sf.jclec.algorithm.multiobjective;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;

import net.sf.jclec.IEvaluator;
import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.IMutator;
import net.sf.jclec.IRecombinator;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.base.FilteredMutator;
import net.sf.jclec.base.FilteredRecombinator;
import net.sf.jclec.fitness.CompositeFitness;
import net.sf.jclec.fitness.IValueFitness;
import net.sf.jclec.fitness.ParetoComparator;
import net.sf.jclec.fitness.ValueFitnessComparator;

import org.apache.commons.configuration.Configuration;

/**
 * "NSGA-II" algorithm.
 * 
 *  	NSGA-II (Non-dominating Sorting Genetic Algorithm) is a multi-objective 
 *  genetic optimization algorithm based on Pareto-optimal front with low 
 *  computational requirements. It is an elitism algorithm. 
 *    	The main feature of NSGA2 is in elitism-preservation operation. 
 *  Firstly, the archive size is set equal to the initial population size. 
 *  The current archive is then determined based on the combination of the 
 *  current population and the previous archive. To do this, NSGA2 uses 
 *  dominance ranking to classify the population into a number of layers, 
 *  and a truncation operator is applied to that layer based on crowding 
 *  distance. 
 *   
 * @author Amelia Zafra
 * @author Revised by: Jose Maria Luna, Alberto Cano
 */

public class NSGA2 extends PopulationAlgorithm
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -7514647303485840499L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Pareto population */

	private List<IIndividual> paretoFront = new ArrayList<IIndividual>();

	/** Pareto comparator */

	static ParetoComparator paretoComparator = new ParetoComparator();

	/** Individuals mutator */

	protected FilteredMutator mutator;

	/** Individuals recombinator */

	protected FilteredRecombinator recombinator;

	/** It stores the variables associated to each individual of NSGAII algorithm  */

	Hashtable<IIndividual, PropertyIndividualsNSGA2> individualProperty = new Hashtable<IIndividual, PropertyIndividualsNSGA2>();

	/** Maximize fitness */

	private boolean maximize = true;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 */

	public NSGA2() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------- Setting and getting properties
	/////////////////////////////////////////////////////////////////

	/**
	 * Access to parents recombinator
	 * 
	 * @return Actual parents recombinator
	 */

	public FilteredRecombinator getRecombinator() 
	{
		return recombinator;
	}

	/**
	 * Sets the parents recombinator.
	 * 
	 * @param recombinator New parents recombinator
	 */

	public void setRecombinator(IRecombinator recombinator) 
	{
		if(this.recombinator == null)
			this.recombinator = new FilteredRecombinator(this);

		this.recombinator.setDecorated(recombinator);
	}

	/**
	 * Access to individuals mutator.
	 * 
	 * @return Individuals mutator
	 */

	public FilteredMutator getMutator() 
	{
		return mutator;
	}

	/**
	 * Set individuals mutator.
	 * 
	 * @param mutator Individuals mutator
	 */

	public void setMutator(IMutator mutator) 
	{
		if(this.mutator == null)
			this.mutator = new FilteredMutator(this);

		this.mutator.setDecorated(mutator);
	}

	/**
	 * Set individuals evaluator.
	 *  
	 * @param evaluator Individuals evaluator
	 */

	@SuppressWarnings("unchecked")
	public void setEvaluator(IEvaluator evaluator)
	{
		this.evaluator = evaluator;

		Comparator<IFitness> componentComparators [] = new Comparator[2];
		componentComparators[0] = new ValueFitnessComparator(!maximize);
		componentComparators[1] = new ValueFitnessComparator(!maximize);

		// Set comparators of the multi-objective
		paretoComparator.setComponentComparators(componentComparators);
	}

	/**
	 * Set the recombinator probability
	 */

	public void setRecombinationProb(double recProb) 
	{
		((FilteredRecombinator) this.recombinator).setRecProb(recProb);
	}	

	/**
	 * Set the mutator probability
	 */

	public void setMutationProb(double mutProb) 
	{
		((FilteredMutator) this.mutator).setMutProb(mutProb);
	}

	/**
	 * Get the pareto front
	 */
	public List<IIndividual> gePareto()
	{
		return this.paretoFront;
	}

	/**
	 * @return the maximize
	 */
	public boolean isMaximize() {
		return maximize;
	}

	/**
	 * @param maximize the maximize to set
	 */
	public void setMaximize(boolean maximize) {
		this.maximize = maximize;
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------- Implementing IConfigure interface
	/////////////////////////////////////////////////////////////////

	public void configure(Configuration settings)
	{
		super.configure(settings);
	}	

	/////////////////////////////////////////////////////////////////
	// --------------------- Overwriting PopulationAlgorithm methods
	/////////////////////////////////////////////////////////////////

	protected void doSelection() {
		if(generation == 1)
			pset = bset;
		else
			// Select parents
			pset = select(bset);
	}

	protected void doGeneration() {
		// Do Nothing
	}

	protected void doReplacement() {
		// Do Nothing
	}

	/**
	 * 
	 * This method performs:
	 * 
	 * Step1: To organize the population in fronts of nondominated individuals.
	 * Assigning to each individual the value of the front to which it belongs
	 * (fastNodominatedSort).
	 * 
	 * Step2: To get an estimate of the density of solution surronunding a
	 * particular solution in the population, we calculate the average
	 * distance of two points on either side of this point along each of 
	 * the objetives. This quantity serves as an estimate of the 
	 * perimeter of the cuboid formed by using the nearest neighbors
	 * as the vertices (crowdingDistanceAssignment).
	 * 
	 * Step3: To update the new population, assigning individual from
	 * the first front towards the last front, while the size
	 * of the population is not completed (updatePop).
	 * 
	 * Step4: The crowded-comparison operator guides the selection process
	 * at the various stages of the algorithm toward a uniformly
	 * spread-out Pareto-optimal front. Assume that every individual
	 * in the population has two attributes: nondomination front and 
	 * crowding distance. Hence, between two solutions with differing
	 * nondomination fronts, we prefer the solution with the lower(better)
	 * front. Otherwise, if both solutions belong to the same front,
	 * then we prefer the solution that is located in a lesser crowded
	 * region.
	 * 
	 * Step5: To assign the new population of size N to the next generation
	 * 
	 */

	protected void doUpdate() {

		// Unite the populations (cSetName and bSetName)
		List<IIndividual> aset = new ArrayList<IIndividual> ();

		aset.addAll(bset);

		for(IIndividual ind : cset)
			if(!aset.contains(ind))
				aset.add((IIndividual) ind);

		//Clear the list of fronts
		List<List<IIndividual>> indFronts  = new ArrayList<List<IIndividual>>();

		//Clear the table
		individualProperty.clear();

		//The individuals are sorted by fronts
		indFronts = fastNonDominatedSort(aset);

		//Assigment to each individual the value of the perimeter 
		//of its bucket by means of the previous and later 
		//individuals of each front
		for(List<IIndividual> ind : indFronts) 
			crowdingDistanceAssignment(ind);

		//We set the new population
		List<IIndividual> newSet = new ArrayList<IIndividual>();
		int size =  bset.size();
		int index = 0;

		// The new population is created with the indiviudos of the first fronts 
		while((newSet.size() + indFronts.get(index).size()) < size )
		{
			newSet.addAll(indFronts.get(index));
			index++;
		}

		int fill = size-newSet.size();

		sortedCrowdingDistanceAssignment(indFronts.get(index));

		for(int j=0; j<fill; j++)
			newSet.add(indFronts.get(index).get(j));

		//Sets new nodominated set
		paretoFront.clear();

		for(IIndividual ind : indFronts.get(0))
			if(!paretoFront.contains(ind))
				paretoFront.add(ind);

		bset = newSet;

		// Clear pset & rset
		cset = pset = null;
	}


	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 *   Select the parents set. The selection method uses is a 
	 * tournament selection, the selection process lead to the algorithm toward 
	 * a uniformly spread-out Pareto-optimal front. Assume that every individual 
	 * in the population has two attributes: nondomination front and crowding 
	 * distance. Hence, between two solutions with differing nondomination fronts, 
	 * we prefer the solution with the lower(better)front. Otherwise, if both solutions 
	 * belong to the same front, then we prefer the solution that is located in a lesser 
	 * crowded region.
	 * 
	 * @param group Individuals set to select
	 * 
	 * @return Selected individuals
	 * 
	 */

	private List<IIndividual> select(List<IIndividual> group)
	{
		// Set the selection parameters
		int tsize = 2;
		PropertyIndividualsNSGA2 propTmp;
		PropertyIndividualsNSGA2 propTmp2;
		//Result of the selection
		ArrayList<IIndividual> selection = new ArrayList<IIndividual>();

		//Size of the list of the individuals		
		int grpsiz = group.size();
		int grplm1 = grpsiz - 1;
		int [] individuos = new int[group.size()];
		int tmpNum, tmp2Num, aux;

		//It is guaranteed that duplicate individuals do not select 
		//themselves to	cross themselves
		for(int i=0; i<grpsiz; i++)
			individuos[i] = i;

		// Selection to make
		for (int i=0; i<grpsiz-1; i++)
		{
			// Random selected individual
			tmpNum = randGenFactory.createRandGen().choose(i,grplm1);
			IIndividual tmp = group.get(individuos[tmpNum]);
			propTmp = individualProperty.get(tmp);

			// Binary Tournament
			for (int j=1; j<tsize; j++) 
			{
				tmp2Num = randGenFactory.createRandGen().choose(i,grplm1);
				IIndividual tmp2 = group.get(individuos[tmp2Num]);
				propTmp2 = individualProperty.get(tmp2);
				if( propTmp.getFront() > propTmp2.getFront())
				{
					tmp = tmp2;
					tmpNum = tmp2Num;
				}
				else if (propTmp.getFront() == propTmp2.getFront() && propTmp.getCubePerimeter() < propTmp2.getCubePerimeter())
				{
					tmp = tmp2;
					tmpNum = tmp2Num;
				}
			}

			// Individual added to the list
			selection.add(tmp);

			//It is eliminated the selected individual, so that 
			// it does not become to select again
			aux = individuos[i];
			individuos[i] = individuos[tmpNum];
			individuos[tmpNum] = aux;
		}

		selection.add(group.get(individuos[grpsiz-1]));
		return selection;
	}

	/**
	 * 
	 * Decreasing Sort the individuals of same front, according to the
	 * perimeter 

	 * @param front individuals list of same front
	 * 
	 */

	private void sortedCrowdingDistanceAssignment(List<IIndividual> front)
	{
		// Properties of the individuals
		PropertyIndividualsNSGA2 prop1;
		PropertyIndividualsNSGA2 prop2;

		//Sort by the property of the perimeter of the bucket
		for(int i=0; i<front.size(); i++)
		{
			prop1 = individualProperty.get(front.get(i));

			for(int j=i+1; j<front.size(); j++)
			{
				prop2 = individualProperty.get(front.get(j));

				if(prop1.getCubePerimeter() < prop2.getCubePerimeter())
				{
					IIndividual auxInd = front.get(j);
					front.remove(j);
					front.add(i, auxInd);
					prop1 = prop2;
				}					
			}
		}
	}

	/**
	 * 
	 * Sort the individual by nondominated fronts, of this way, the 
	 * front1 will be constituted by all the nondominated individuals 
	 * by others, the front2 will be constituted by the nondominated 
	 * individuals by others, but in this case, it is considered 
	 * eliminated the individuals that belong to the front1, 
	 * and so on.
	 * 
	 * @param pob The population which is going to order by front
	 * 
	 * @return auxFront The population organizated by fronts
	 */

	private List<List<IIndividual>> fastNonDominatedSort(List<IIndividual> pob)
	{
		//It is stored the nondominated individuals in each front
		List<IIndividual> auxiliarDominated = new ArrayList<IIndividual>(); 
		//It is stored the individuals belong to each front
		List<IIndividual> auxiliarFront = new ArrayList<IIndividual>();
		//Specific properties of the individuals of NSGAII algorithm 
		PropertyIndividualsNSGA2 [] propInd = new PropertyIndividualsNSGA2[pob.size()];
		// It is stored the individuals organized in fronts
		List<List<IIndividual>> auxiliarListFronts  = new ArrayList<List<IIndividual>>();

		// It is initialized an object of properties for each 
		// one of the individuals
		for(int i=0; i<pob.size();i++)
			propInd[i] = new PropertyIndividualsNSGA2();

		//It is established the parameters of each individuals.
		//These are the number of individuals that they dominate and the 
		//number of individuals that dominate to him 
		for(int i=0; i<pob.size(); i++) 
		{
			for(int j=0; j<pob.size(); j++)
			{
				// The first step is to calculate the number of individuals 
				// which dominate each individual

				switch(paretoComparator.compare((CompositeFitness)pob.get(i).getFitness(), (CompositeFitness) pob.get(j).getFitness()))
				{
				//if the result is equal to 1 it means that i dominates j
				case 1:
					auxiliarDominated.add(pob.get(j));
					break;

					//if the result is equal to -1 it means that j dominates i
				case -1:
					propInd[i].setDomainedBy(propInd[i].getDomainedBy()+1);
					break;

					//if the result is equal to 0 there isn`t relation of "dominancia" 
				case 0:
					break;
				}
			}

			//the list of dominated individuals is added to 
			//the general list
			propInd[i].setDominatedList(auxiliarDominated);
			//The auxiliar elements are eliminated
			auxiliarDominated.clear();

			// If the individual is not dominated by any other, 
			// it sets that	the individual belongs to the first front
			if (propInd[i].getDomainedBy() == 0)
			{
				propInd[i].setFront(1);
				auxiliarFront.add(pob.get(i));

			}
			// It is indexed each property of the individual with same himself
			individualProperty.put(pob.get(i), propInd[i]);
		}

		//It is added the individuals that belong to the first front
		List<IIndividual> tmp = new ArrayList<IIndividual>();
		tmp.addAll(auxiliarFront);
		auxiliarListFronts.add(tmp);

		//It is initialized the necessary variables
		int numFront = 0;
		List<IIndividual> previousFront;
		PropertyIndividualsNSGA2 propFrente, propDominatedInd;

		//It is established the front to which each individual belongs
		while (auxiliarListFronts.get(numFront).size() != 0)
		{
			auxiliarFront.clear();
			previousFront = auxiliarListFronts.get(numFront); 

			for(int i=0; i < previousFront.size(); i++)
			{
				propFrente = individualProperty.get(previousFront.get(i));
				for(int j=0; j < (propFrente.getDominatedList()).size(); j++)
				{
					propDominatedInd = individualProperty.get((propFrente.getDominatedList()).get(j));

					propDominatedInd.setDomainedBy(propDominatedInd.getDomainedBy() - 1);

					if(propDominatedInd.getDomainedBy() == 0)
					{
						propDominatedInd.setFront(numFront + 1);
						auxiliarFront.add((propFrente.getDominatedList()).get(j));
					}
				}
			}

			numFront++;
			tmp = new ArrayList<IIndividual>();
			tmp.addAll(auxiliarFront);
			auxiliarListFronts.add(tmp);
		}

		// It is eliminate the last element
		auxiliarListFronts.remove(auxiliarListFronts.size()-1);

		return auxiliarListFronts;
	}

	/**
	 * Compute an estimate of the density of solution surronunding a
	 * particular solution in the same front, we calculate the average
	 * distance of two points on either side of this point along each of 
	 * the objetives. This quantity serves as an estimate of the 
	 * perimeter of the cuboid formed by using the nearest neighbors
	 * as the vertices.
	 * 
	 *@param front The individuals of front modify theirs estimation
	 *of the density based in parameter of cuboPerimeter
	 */
	private void crowdingDistanceAssignment(List<IIndividual> front)
	{
		List<IIndividual> sortedFront;
		double auxDouble, fMax, fMin;
		int frontSize = front.size();
		int numberObjectives = ((CompositeFitness) (front.get(0)).getFitness()).getComponents().length;

		//The parameter that represents the perimeter of the
		//bucket is initialized to 0.
		for(int i=0; i<frontSize; i++)
			individualProperty.get(front.get(i)).setCuboPerimeter(0);

		
		//For each objetive 'm' 
		for(int objective=0; objective<numberObjectives; objective++)
		{
			// Sort the individuals of this front by the objective
			sortedFront = sortFronts(front, objective);

			// The last and first individual have a infinite value
			individualProperty.get(sortedFront.get(0)).setCuboPerimeter(Double.MAX_VALUE);	
			individualProperty.get(sortedFront.get(frontSize-1)).setCuboPerimeter(Double.MAX_VALUE);

			// Maximum and minimum of objective function
			fMin = ((IValueFitness) ((CompositeFitness) (sortedFront.get(0)).getFitness()).getComponent(objective)).getValue();
			fMax = ((IValueFitness) ((CompositeFitness) (sortedFront.get(frontSize - 1)).getFitness()).getComponent(objective)).getValue();

			if(fMin!=fMax){
				for(int i=1; i<frontSize-1; i++)
				{
					auxDouble = Math.abs( ((IValueFitness) ((CompositeFitness) (sortedFront.get(i+1)).getFitness()).getComponent(objective)).getValue() - ((IValueFitness) ((CompositeFitness) (sortedFront.get(i-1)).getFitness()).getComponent(objective)).getValue());
					auxDouble = auxDouble / Math.abs(fMax - fMin);
					individualProperty.get(sortedFront.get(i)).setCuboPerimeter(individualProperty.get(front.get(i)).getCubePerimeter() + auxDouble);
				}
			}
		}
	}


	/**
	 * 
	 * Sort the list of individuals according to the objective function 
	 * which is indicated by function argument.
	 * 
	 * @param source, List of individuals which are going to order by the
	 * objetive function indicated
	 * @param numObj Number which represents the function objective which 
	 * is used.
	 * 
	 * @return the list of individuals sorted accordint to objective function (numObj)
	 */

	private List<IIndividual> sortFronts(List<IIndividual> source, int numObj)
	{
		// Selection result
		List<IIndividual> result = new ArrayList<IIndividual>(source);

		//Sort in increasing values of the criteria 'numObj'
		ComparatorByObjectives comparatorObjectives = new ComparatorByObjectives();
		comparatorObjectives.setNumberObjective(numObj);
		Collections.sort(result, comparatorObjectives.comparatorByObjectives);

		// Return the result
		return result;
	}

	/**
	 * Properties of the NSGA2 individuals
	 * 
	 * @author Amelia Zafra Gi?oemez
	 *
	 * Revised by: Josi?oe Mari?oea Luna Ariza
	 */

	private class PropertyIndividualsNSGA2 
	{
		////////////////////////////////////////////////////////////////////
		// ------------------------------------------------------ Properties
		////////////////////////////////////////////////////////////////////

		/** Front of individual */

		private int front;

		/** Perimeter of the bucket formed by the vertices of its neighbours */

		private double cuboPerimeter;

		/** Number of individual which dominate it  */

		private int domainedBy;

		/** Individual list which are dominated by it */

		protected List<IIndividual> dominatedList = new ArrayList<IIndividual>();

		/////////////////////////////////////////////////////////////////
		// ------------------------------------------------- Constructors
		/////////////////////////////////////////////////////////////////

		public PropertyIndividualsNSGA2()
		{
			this.domainedBy = 0;
			this.cuboPerimeter = 0.0;
			this.front = 0;
			this.dominatedList.clear();
		}

		/////////////////////////////////////////////////////////////////
		// ------------------------------- Setting and getting properties
		/////////////////////////////////////////////////////////////////

		/**
		 * Set the new front value.
		 *
		 * @param front New front value.
		 */

		public void setFront(int front)
		{
			this.front = front;
		}

		/**
		 * Return the value de front.
		 *
		 * @return front of individual.
		 */

		public int getFront()
		{
			return this.front;
		}

		/**
		 * Set the new value of bucket perimeter formed by the vertices of 
		 * its neighbours closest 
		 *
		 * @param cuboPerimeter New value of bucket perimeter.
		 */

		public void setCuboPerimeter(double cuboPerimeter)
		{
			this.cuboPerimeter = cuboPerimeter;
		}

		/**
		 * Return the value of bucket perimeter.
		 *
		 * @return bucket perimeter forme by its neighbours.
		 */

		public double getCubePerimeter()
		{
			return this.cuboPerimeter;
		}

		/**
		 * Set the new value of individuals number which dominate it.
		 *
		 * @param domainedBy New value of individual number which dominate it.
		 */

		public void setDomainedBy(int domainedBy)
		{
			this.domainedBy = domainedBy;
		}

		/**
		 * Return the value of individuals number which dominate it.
		 *
		 * @return domainedBy number of individuals which dominate it.
		 */

		public int getDomainedBy()
		{
			return this.domainedBy;
		}

		/**
		 * Set the list of individuals which are dominated by current individual.
		 *
		 * @param dominatedList New dominated individual list.
		 */

		public void setDominatedList(List<IIndividual> dominatedList)
		{
			this.dominatedList.addAll(dominatedList);
		}

		/**
		 * Return list of dominated individuals.
		 *
		 * @return Dominated Individual List.
		 */

		public List<IIndividual> getDominatedList()
		{
			return this.dominatedList;
		}
	}

	/**
	 *  
	 *  Compare two individuals according to objective function 
	 *  indicated.
	 *  
	 */
	private class ComparatorByObjectives
	{
		private int numberObjective;

		public void setNumberObjective(int numberObjective)
		{
			this.numberObjective = numberObjective;
		}

		Comparator<IIndividual> comparatorByObjectives = new Comparator<IIndividual>()
				{
			public int compare(IIndividual arg0, IIndividual arg1) 
			{
				return paretoComparator.getComponentComparators()[numberObjective].compare(((CompositeFitness) arg0.getFitness()).getComponent(numberObjective), ((CompositeFitness) arg1.getFitness()).getComponent(numberObjective));
			}		
				};

	}
}