package net.sf.jclec.algorithm.classic;

import net.sf.jclec.IMutator;
import net.sf.jclec.ISelector;
import net.sf.jclec.IConfigure;
import net.sf.jclec.IIndividual;
import net.sf.jclec.IRecombinator;

import net.sf.jclec.base.FilteredMutator;
import net.sf.jclec.base.FilteredRecombinator;

import net.sf.jclec.algorithm.PopulationAlgorithm;

import net.sf.jclec.selector.BettersSelector;

import org.apache.commons.lang.builder.EqualsBuilder;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationRuntimeException;

/**
 * <strong><u>S</u></strong>teady <strong><u>S</u></strong>tate algorithm.
 * 
 * @author Sebastian Ventura
 */

public class SS extends PopulationAlgorithm 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8711970425735016406L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Number of parents to select and replace */
	
	protected int numberOfParents;
	
	/** Parents selector */
	
	protected ISelector parentsSelector;
	
	/** Recombination operator */
	
	protected IRecombinator recombinator;

	/** Mutation operator */
	
	protected IMutator mutator;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////

	/** Used in update phase */
	
	protected BettersSelector bettersSelector = new BettersSelector(this);

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */
	
	public SS() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// Getting and setting properties

	public final int getNumberOfParents() 
	{
		return numberOfParents;
	}

	public final void setNumberOfParents(int numberOfParents) 
	{
		this.numberOfParents = numberOfParents;
	}

	public final ISelector getParentsSelector() 
	{
		return parentsSelector;
	}

	public final void setParentsSelector(ISelector parentsSelector) 
	{
		// Set parents selector
		this.parentsSelector = parentsSelector;
		// Contextualize selector
		parentsSelector.contextualize(this);
	}

	public final IRecombinator getRecombinator() 
	{
		return recombinator;
	}

	public final void setRecombinator(IRecombinator recombinator) 
	{
		if (recombinator instanceof FilteredRecombinator) {
			throw new IllegalArgumentException
				("FilteredRecombinator is invalid in Steady state algorithms");
		}
		else {
			// Set recombinator
			this.recombinator = recombinator;
			// Contextualize recombinator
			recombinator.contextualize(this);
		}
	}

	public final IMutator getMutator() 
	{
		return mutator;
	}

	public final void setMutator(IMutator mutator) 
	{
		// Set mutator
		this.mutator = mutator;
		// Contextualize mutator
		mutator.contextualize(this);
	}

	// IConfigure interface
	
	/**
	 * Configuration method. 
	 * 
	 * Configuration parameters for an Steady State algorithm are:
	 * 
	 * <ul>
	 * </ul>
	 */
	
	@SuppressWarnings("unchecked")
	public void configure(Configuration settings)
	{
		// Call super.configure() method
		super.configure(settings);
		// Set number-of-parents
		int numberOfParents = settings.getInt("number-of-parents", 2);
		setNumberOfParents(numberOfParents);
		// Parents selector
		try {
			// Selector classname
			String parentsSelectorClassname = 
				settings.getString("parents-selector[@type]");
			// Species class
			Class<? extends ISelector> parentsSelectorClass = 
				(Class<? extends ISelector>) Class.forName(parentsSelectorClassname);
			// Species instance
			ISelector parentsSelector = parentsSelectorClass.newInstance();
			// Configure species if necessary
			if (parentsSelector instanceof IConfigure) {
				// Extract species configuration
				Configuration parentsSelectorConfiguration = settings.subset("parents-selector");
				// Configure species
				((IConfigure) parentsSelector).configure(parentsSelectorConfiguration);
			}
			// Set species
			setParentsSelector(parentsSelector);
		} 
		catch (ClassNotFoundException e) {
			throw new ConfigurationRuntimeException("Illegal parents selector classname");
		} 
		catch (InstantiationException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of parents selector", e);
		} 
		catch (IllegalAccessException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of parents selector", e);
		}
		// Recombinator
		try {
			// Recombinator classname
			String recombinatorClassname = 
				settings.getString("recombinator[@type]");
			// Recombinator class
			Class<? extends IRecombinator> recombinatorClass = 
				(Class<? extends IRecombinator>) Class.forName(recombinatorClassname);
			// Recombinator instance
			IRecombinator recombinator = recombinatorClass.newInstance();
			// Configure recombinator
			if (recombinator instanceof IConfigure) {
				Configuration recombinatorSettings = settings.subset("recombinator");
				((IConfigure) recombinator).configure(recombinatorSettings);
			}
			// Set recombinator
			setRecombinator(recombinator);
		} 
		catch (ClassNotFoundException e) {
			throw new ConfigurationRuntimeException("Illegal recombinator classname");
		} 
		catch (InstantiationException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of recombinator", e);
		} 
		catch (IllegalAccessException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of recombinator", e);
		}
		// Mutator
		try {
			// Mutator classname
			String mutatorClassname = 
				settings.getString("mutator[@type]");
			// Recombinator class
			Class<? extends IMutator> mutatorClass = 
				(Class<? extends IMutator>) Class.forName(mutatorClassname);
			// Recombinator instance
			IMutator mutator = mutatorClass.newInstance();
			// Configure mutator
			if (mutator instanceof IConfigure) {
				Configuration mutatorSettings = settings.subset("mutator");
				((IConfigure) mutator).configure(mutatorSettings);
			}
			// Set mutator
			setMutator(mutator);
		} 
		catch (ClassNotFoundException e) {
			throw new ConfigurationRuntimeException("Illegal mutator classname");
		} 
		catch (InstantiationException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of mutator", e);
		} 
		catch (IllegalAccessException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of mutator", e);
		}
	}
	
	// java.lang.Object methods

	@Override
	public boolean equals(Object other)
	{
		if (other instanceof SS) {
			SS cother = (SS) other;
			EqualsBuilder eb = new EqualsBuilder();
			// Call super method
			eb.appendSuper(super.equals(other));
			// Number of parents
			eb.append(numberOfParents, cother.numberOfParents);
			// Parents selector
			eb.append(parentsSelector, cother.parentsSelector);
			// Mutator
			eb.append(mutator, cother.mutator);
			// Recombinator
			eb.append(recombinator, cother.recombinator);
			// Return test result
			return eb.isEquals();
		}
		else {
			return false;
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	// PopulationAlgorithm methods

	@Override
	protected void doSelection() 
	{
		pset = parentsSelector.select(bset, numberOfParents);		
	}

	@Override
	protected void doGeneration() 
	{
		// Recombine parents
		cset = recombinator.recombine(pset);
		// Mutate sons
		cset = mutator.mutate(cset);
		// If mutator is a filtered mutator...
		if (mutator instanceof FilteredMutator) {
			FilteredMutator fmutator = (FilteredMutator) mutator;
			for (IIndividual sterile : fmutator.getSterile()) 
				cset.add(sterile.copy());
		}
		// Evaluate all new individuals
		evaluator.evaluate(cset);
	}

	@Override
	protected void doReplacement() 
	{
		// Remove all parents from bset
		for (IIndividual ind : pset) {
			bset.remove(ind);
		}
	}

	@Override
	protected void doUpdate() 
	{
		// Adding parents to cset 
		for (IIndividual ind : pset) {
			cset.add(ind);
		}		
		// Selecting best individuals in bset
		cset = bettersSelector.select(cset, numberOfParents);		
		// Add selected individuals to bset
		bset.addAll(cset);
		// Cleaning cset, pset
		cset = pset = null;
			
	}
}
