package net.sf.jclec.realarray.mut;

import net.sf.jclec.realarray.UniformMutator;

import net.sf.jclec.util.range.Interval;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * This mutator applies on each selected individual a random mutation, in other 
 * words, the locus  value changes randomly. This  value is inside of the locus 
 * interval.
 *
 * @author Alberto Lamarca
 * @author Sebastian Ventura 
 */

public class NonUniformMutator extends UniformMutator 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */
	
	private static final long serialVersionUID = 6181346796048579933L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
	
	/** User parameter */
	
	private double b;
	
	/** Maximun generation number */
	
	private double gmax;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////
	
	/** Current generation */
	
	private transient double actualGeneration;
	
	/** Exponent */
	
    private transient double exp;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor
	 */
	
	public NonUniformMutator() 
	{
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// Setting and getting properties

	/**
	 * @return Returns the b parameter
	 */
	
	public double getB() 
	{
		return b;
	}
	
	/**
	 * @param b parameter to set.
	 */
	
	public void setB(double b) 
	{
		this.b = b;
	}
	
	/**
	 * @return Returns the Maximun generation number
	 */
	
	public int getGmax() 
	{
		return (int) gmax;
	}
	
	/**
	 * @param gmax Maximun generation number to set.
	 */
	
	public void setGmax(int gmax) 
	{
		this.gmax = (double) gmax;
	}
	
	// IConfigure interface

	/**
	 * 
	 */
	
	@Override
	public void configure(Configuration settings)
	{
		// Call super.configure() method
		super.configure(settings);
		// Set b parameter
		double b = settings.getDouble("[@b]", 5.0);
		setB(b);
		// Set gmax parameter
		int gmax = settings.getInt("[@g-max]", 100);
		setGmax(gmax);
	}

	// java.lang.Object methods

	@Override
	public boolean equals(Object other)
	{
		if (other instanceof NonUniformMutator) {
			NonUniformMutator o = (NonUniformMutator) other;
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(locusMutProb, o.locusMutProb);
			eb.append(b, o.b);
			eb.append(gmax, o.gmax);
			return eb.isEquals();
		}
		else {
			return false;
		}
	}	

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	// AbstractMutator methods

	/**
	 * Sets actual generation
	 * 
	 * @inheritDoc
	 */
	
	@Override
	public void prepareMutation()
	{
		// Gets genotype length and schema
		super.prepareMutation();
		// Gets actual generation
		actualGeneration = (double) context.getGeneration();
		// Update exp value
		exp = Math.pow(1-(actualGeneration/gmax), b);
	}

	// UniformMutator methods
	
    /**
	 * {@inheritDoc}
	 */
	
	@Override
	protected void doLocusMutation(double[] parentChromosome, double[] mutantChromosome, int locusIndex) 
	{
		double newValue;
		if(randgen.coin()) {
			double triang = 
				(parentChromosome[locusIndex] - ((Interval) genotypeSchema[locusIndex]).getLeft());
			triang *= (1-Math.pow(randgen.raw(),exp));
			newValue = parentChromosome[locusIndex] - triang;
		}
		else {
			double triang = 
				(((Interval)genotypeSchema[locusIndex]).getRight() - parentChromosome[locusIndex]);
			triang *= (1-Math.pow(randgen.raw(),exp));			  
			newValue = parentChromosome[locusIndex] + triang;
		}
		// Check the locus interval
		mutantChromosome[locusIndex] = genotypeSchema[locusIndex].nearestOf(newValue);		
	}
	
	/**
	 * {@inheritDoc}
	 */
	
	@Override
	protected double defaultLocusMutProb() 
	{
		return 0.05;
	}

}


