package net.sf.jclec.realarray.rec;

import net.sf.jclec.realarray.RealArrayIndividual;
import net.sf.jclec.realarray.UniformCrossover;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Apply a linear crossover for two individuals.
 *  
 * @author Alberto Lamarca 
 * @author Sebastian Ventura 
 */

public class LinearCrossover extends UniformCrossover 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -1076990295779312238L;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor
	 */
	
	public LinearCrossover() 
	{
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// java.lang.Object methods
	
	public boolean equals(Object other)
	{
		if (other instanceof LinearCrossover) {
			LinearCrossover o = (LinearCrossover) other;
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(locusRecProb, o.locusRecProb);
			return eb.isEquals();
		}
		else {
			return false;
		}
	}	
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	// UniformCrossover methods
	
	@Override
	protected void setPpl()
	{
		ppl = 2;
	}
	
	/**
	 * Function that returns sons number
	 * 
	 * @return 3  for the linear crossover
	 */

	@Override
	protected void setSpl() 
	{
		spl = 3;
	}

	/**
	 * {@inheritDoc}
	 */
	
	@Override
	public void recombineNext() 
	{
		// Parents genotypes
		double [] p0_genome = 
			((RealArrayIndividual) parentsBuffer.get(parentsCounter)).getGenotype();
		double [] p1_genome = 
			((RealArrayIndividual) parentsBuffer.get(parentsCounter+1)).getGenotype();
		// Creating sons genotypes
		double [] s0_genome = new double[genotypeLength];
		double [] s1_genome = new double[genotypeLength];
		double [] s2_genome = new double[genotypeLength];
		// Building cross segment
		for (int i=0; i<genotypeLength; i++)
		{
			if(randgen.coin(locusRecProb)) {
				s0_genome[i] = 
					genotypeSchema[i].nearestOf(0.5 * p0_genome[i] + 0.5 * p1_genome[i]);
				s1_genome[i] = 
					genotypeSchema[i].nearestOf(1.5 * p0_genome[i] - 0.5 * p1_genome[i]);
				s2_genome[i] = 
					genotypeSchema[i].nearestOf(-0.5 * p0_genome[i] + 1.5 * p1_genome[i]);
			}
			else {
				s0_genome[i] = p0_genome[i];
				s1_genome[i] = p0_genome[i];
				s2_genome[i] = p1_genome[i];
			}			
		}
		// Put sons in buffer
		sonsBuffer.add(species.createIndividual(s0_genome)) ;
		sonsBuffer.add(species.createIndividual(s1_genome));
		sonsBuffer.add(species.createIndividual(s2_genome));
	}

	@Override
	protected double defaultLocusRecProb() 
	{
		return 0.6;
	}	
}
