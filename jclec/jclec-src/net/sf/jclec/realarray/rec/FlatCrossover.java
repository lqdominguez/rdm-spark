package net.sf.jclec.realarray.rec;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Apply a flat crossover for two individuals.
 *
 * @author Alberto Lamarca 
 * @author Sebastian Ventura 
 */

public class FlatCrossover extends UniformCrossover2x1 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -4888801834352998287L;
		
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor
	 */
		
	public FlatCrossover() 
	{
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	// java.lang.Object methods
	
	public boolean equals(Object other)
	{
		if (other instanceof FlatCrossover) {
			FlatCrossover o = (FlatCrossover) other;
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(locusRecProb, o.locusRecProb);
			return eb.isEquals();
		}
		else {
			return false;
		}
	}	
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	// UniformCrossover2x1 methods
	
	@Override
	protected void recombineLocus(double[] p0_genome, double[] p1_genome, double[] s0_genome, int locusIndex) 
	{
		double c1 = Math.min(p0_genome[locusIndex], p1_genome[locusIndex]);
		double c2 = Math.max(p0_genome[locusIndex], p1_genome[locusIndex]);
		s0_genome[locusIndex] = c1 + (randgen.raw()*(c2-c1));
	}

	// UniformCrossover methods
	
	@Override
	protected double defaultLocusRecProb() 
	{
		return 0.6;
	}
}
