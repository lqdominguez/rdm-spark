package net.sf.jclec.realarray.rec;

import net.sf.jclec.IPopulation;

import org.apache.commons.configuration.Configuration;

import org.apache.commons.lang.builder.EqualsBuilder;

/** 
 * Apply the BLX-alfa crossover for  two individuals. This crossover depends on 
 * alfa parameter which  decides the crossover interval. If alfa value is zero, 
 * this crossover is equal than flat crossover.
 *
 * @author Alberto Lamarca 
 * @author Sebastian Ventura
 */

public class BLXAlphaCrossover extends UniformCrossover2x1 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by eclipse */
	
	private static final long serialVersionUID = 6802959322946378018L;
	
	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
		
	/** Alpha parameter */
	
	protected double alpha;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor
	 */
	
	public BLXAlphaCrossover() 
	{
		super();
	}
	
	/**
	 * Constructor that set execution context.
	 * 
	 * @param context Execution context
	 */
	
	public BLXAlphaCrossover(IPopulation context) 
	{
		super(context);
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// Setting and getting properties

	/**
	 * @return Alpha parameter value
	 */
	
	public final double getAlpha() 
	{
		return alpha;
	}
	
	/**
	 * Set the alpha parameter value.
	 * 
	 * @param alpha Alpha parameter value 
	 */
	
	public final void setAlpha(double alpha) 
	{
		this.alpha = alpha;
	}
	
	// IConfigure interface

	@Override
	public void configure(Configuration settings)
	{
		// Call super.configure method
		super.configure(settings);
		// Set alpha parameter
		double alpha = settings.getDouble("[@alpha]", 0.5);
		setAlpha(alpha);
	}

	// java.lang.Object methods
	
	public boolean equals(Object other)
	{
		if (other instanceof BLXAlphaCrossover) {
			BLXAlphaCrossover o = (BLXAlphaCrossover) other;
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(locusRecProb, o.locusRecProb);
			eb.append(alpha, o.alpha);
			return eb.isEquals();
		}
		else {
			return false;
		}
	}	

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	// UniformCrossover2x1 methods
	
	@Override
	protected void recombineLocus(double[] p0_genome, double[] p1_genome, double[] s0_genome, int locusIndex) 
	{
		// Calculate mutated value
		double cmax = Math.max(p0_genome[locusIndex], p1_genome[locusIndex]);
		double cmin = Math.min(p1_genome[locusIndex], p0_genome[locusIndex]);
		double inf = cmin-(cmax-cmin)*alpha;
		double sup = cmax+(cmax-cmin)*alpha;
		// Sets mutated value 
		s0_genome[locusIndex] = inf+(randgen.raw()*(sup-inf));
		//Check interval locus				
		s0_genome[locusIndex] = 
			genotypeSchema[locusIndex].nearestOf(s0_genome[locusIndex]);			
	}

	// UniformCrossover methods

	@Override
	protected double defaultLocusRecProb() 
	{
		return 0.6;
	}
}
