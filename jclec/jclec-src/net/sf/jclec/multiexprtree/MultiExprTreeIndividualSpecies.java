package net.sf.jclec.multiexprtree;

import net.sf.jclec.IConfigure;
import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.exprtree.ExprTreeSchema;
import net.sf.jclec.exprtree.IPrimitive;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationRuntimeException;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * ExpreTreeIndividual species.
 * 
 * @author Sebastian Ventura
 */

public class MultiExprTreeIndividualSpecies extends MultiExprTreeSpecies implements IConfigure 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -5304951511814536309L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public MultiExprTreeIndividualSpecies() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	// Setting and getting properties
	
	/**
	 * Set the number of prefix expressions per individual 
	 */
	
	public void setNumberOfExprTrees(int numberOfExpressionTrees)
	{
		// Allocate space for genotype schema
		genotypeSchema = new ExprTreeSchema[numberOfExpressionTrees];
		// Allocate space for each schema element
		for (int i=0; i<numberOfExpressionTrees; i++) {
			genotypeSchema[i] = new ExprTreeSchema();
		}
	}

	public void setMinTreeSize(int exprTreeIndex, int minimumTreeSize)
	{
		genotypeSchema[exprTreeIndex].setMinTreeSize(minimumTreeSize);
	}

	public void setMaxTreeSize(int exprTreeIndex, int maximumTreeSize)
	{
		genotypeSchema[exprTreeIndex].setMaxTreeSize(maximumTreeSize);
	}
	
	/**
	 * Set the root type for an expression tree.
	 * 
	 * @param exprTreeIndex Expression tree index
	 * @param rootType      Root type for this tree 
	 */
	
	public void setRootType(int exprTreeIndex, Class<?> rootType)
	{
		genotypeSchema[exprTreeIndex].setRootType(rootType);
	}
	
	/**
	 * Set the terminals set for an expression tree.
	 * 
	 * @param exprTreeIndex Expression tree index
	 * @param terminals     Terminals set for this tree
	 */
	
	public void setTerminals(int exprTreeIndex, IPrimitive [] terminals)
	{
		genotypeSchema[exprTreeIndex].setTerminals(terminals);
	}

	/**
	 * Set the functions set for an expression tree.
	 * 
	 * @param exprTreeIndex Expression tree index
	 * @param functions     Functions set for this tree
	 */
	
	public void setFunctions(int exprTreeIndex, IPrimitive [] functions)
	{
		// Set functions
		genotypeSchema[exprTreeIndex].setFunctions(functions);
	}
	
	// IExprTreeSpecies interface
	
	/**
	 * Creates a MultiExprTreeIndividual
	 * 
	 * @return new MultiExprTreeIndividual individual
	 */
	
	public MultiExprTreeIndividual createIndividual() 
	{
		return new MultiExprTreeIndividual();
	}

	/**
	 * {@inheritDoc}
	 */
	
	public MultiExprTreeIndividual createIndividual(ExprTree[] genotype) 
	{
		return new MultiExprTreeIndividual(genotype);
	}

	// IConfigure interface
	
	/**
	 * Configuration method.
	 * 
	 * Configuration parameters for PrefExprIndividualSpecies are:
	 * 
	 * <ul>
	 * </ul>
	 */
	
	@SuppressWarnings("unchecked")
	public void configure(Configuration settings) 
	{
		// Get number of prefix expressions
		int numberOfPrefixExpressions = settings.getInt("[@number-of-trees]", 1);
		setNumberOfExprTrees(numberOfPrefixExpressions);
		// For each prefix expression
		for (int i=0; i<numberOfPrefixExpressions; i++) {
			// Header
			String header = "expression-tree("+i+")";
			// Get minimum-tree-size
			int minTreeSize = settings.getInt(header+".min-tree-size");
			setMinTreeSize(i, minTreeSize);
			// Get minimum-tree-size
			int maxTreeSize = settings.getInt(header+".max-tree-size");
			setMaxTreeSize(i, maxTreeSize);			
			// Get root type
			String rootTypeName = settings.getString(header+".root-type");
			try {
				Class<?> rootType = Class.forName(rootTypeName);
				setRootType(i, rootType);
			} 
			catch (ClassNotFoundException e) {
				throw new ConfigurationRuntimeException("");
			}
			// Get terminals set
			int numberOfTerminals = settings.getList(header+".terminals.terminal[@class]").size();
			IPrimitive [] terminals = new IPrimitive[numberOfTerminals];
			for (int j=0; j<numberOfTerminals; j++) {
				try {
					String terminalClassname = 
						settings.getString(header+".terminals.terminal("+j+")[@class]");
					Class<IPrimitive> terminalClass = 
						(Class<IPrimitive>) Class.forName(terminalClassname);
					terminals[j] = terminalClass.newInstance();
				} 
				catch (ClassNotFoundException e) {
					throw new ConfigurationRuntimeException();
				} 
				catch (InstantiationException e) {
					throw new ConfigurationRuntimeException();
				} 
				catch (IllegalAccessException e) {
					throw new ConfigurationRuntimeException();
				}
			}	
			setTerminals(i, terminals);
			// Get functions set
			int numberOfFunctions = settings.getList(header+".functions.function[@class]").size();
			IPrimitive [] functions = new IPrimitive [numberOfFunctions];
			for (int j=0; j<numberOfFunctions; j++) {
				try {
					String functionClassname = 
						settings.getString(header+".functions.function("+j+")[@class]");
					Class<IPrimitive> functionClass = 
						(Class<IPrimitive>) Class.forName(functionClassname);
					functions[j] = functionClass.newInstance();
				} 
				catch (ClassNotFoundException e) {
					throw new ConfigurationRuntimeException();
				} 
				catch (InstantiationException e) {
					throw new ConfigurationRuntimeException();
				} 
				catch (IllegalAccessException e) {
					throw new ConfigurationRuntimeException();
				}
			}
			setFunctions(i, functions);
		}
	}
	
	// java.lang.Object methods
	
	/**
	 * {@inheritDoc}
	 */
	
	public boolean equals(Object other)
	{
		if (other instanceof MultiExprTreeIndividualSpecies) {
			MultiExprTreeIndividualSpecies cother = (MultiExprTreeIndividualSpecies) other;
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(genotypeSchema, cother.genotypeSchema);
			return eb.isEquals();
		}
		else {
			return false;
		}
	}
}
