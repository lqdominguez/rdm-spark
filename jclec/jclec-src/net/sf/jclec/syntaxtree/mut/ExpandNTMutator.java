package net.sf.jclec.syntaxtree.mut;

import net.sf.jclec.util.random.IRandGen;

import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.syntaxtree.IMutateSyntaxTree;

/**
 * ExpandNT mutator.
 * 
 * Realiza una exploracion del espacio de busqueda de forma incremental,
 * incrementando en cada paso la profundidad de los arboles mediante
 * la modificacion aleatoria de una rama del arbol.
 * 
 * @author Amelia Zafra
 */


public class ExpandNTMutator implements IMutateSyntaxTree 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -2706522794304044852L;

		
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public ExpandNTMutator() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	// java.lang.Object methods

	public boolean equals(Object other)
	{
		if (other instanceof ExpandNTMutator) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	@Override
	public SyntaxTree mutateSyntaxTree(SyntaxTree parent, SyntaxTreeSchema schema, IRandGen randgen)	
	{	
		// Son genotype
		SyntaxTree son = new SyntaxTree(); 		
		// Select a non terminal symbol 
		int p0_branchStart = selectSymbol(parent, schema, randgen);		
		// If a non terminal symbol doesn't exist in tree, copy parents and return 
		if (p0_branchStart == -1) {
			for(int i=0; i<parent.size(); i++)	son.addNode(parent.getNode(i).copy());			
			return son;
		}
		NonTerminalNode selectedSymbol = (NonTerminalNode) parent.getNode(p0_branchStart);		
		// Set branch end 
		int p0_branchEnd = parent.subTree(p0_branchStart);		
		// Determine the maximum size to fill
		int p0_branchDepth = parent.derivSize();
		int p0_swapBranch = 0;
		for(int i=p0_branchStart; i<p0_branchEnd; i++){
			if(parent.getNode(i).arity()!=0)
				p0_swapBranch ++;
		}
		
		// Create son 
		
		// First son fragment
		for (int i=0; i<p0_branchStart; i++) 
			son.addNode(parent.getNode(i).copy());		
		// Calculate the maximum number of derivation of the parent
		int nMaxOfDer = schema.getMaxDerivSize() - p0_branchDepth + p0_swapBranch;
		// Choose a number of derivation greater than its parent and lower than the established maximum
		int nOfDer = randgen.choose(p0_swapBranch+1, nMaxOfDer);
		
		// Second son fragment - Fill the branch
		schema.fillSyntaxBranch(son, selectedSymbol.getSymbol(), nOfDer, randgen);
		
		// Last son fragment
		for(int i=p0_branchEnd; i<parent.size(); i++)	
			son.addNode(parent.getNode(i).copy());
		
		// Return son
		return son;
	}	
	
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Seleccionar un simbolo no terminal cualquiera del arbol.
	 * 
	 * @param tree Arbol donde selecionar un simbolo cualquiera
	 * 
	 * @return Localizacion del simbolo seleccionado
	 */
	
	private final int selectSymbol(SyntaxTree tree, SyntaxTreeSchema schema, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		
		int actPos = startPos;
		for(int i=0; i<treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
			// Check symbol is nontermianl
			if( !schema.isTerminal(tree.getNode(actPos).getSymbol()) )
				return actPos;
		}
		return -1;
	}
}
