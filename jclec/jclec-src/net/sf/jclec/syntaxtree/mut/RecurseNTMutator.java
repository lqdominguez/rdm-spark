package net.sf.jclec.syntaxtree.mut;

import java.util.List;
import java.util.ArrayList;

import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.syntaxtree.IMutateSyntaxTree;

import net.sf.jclec.util.random.IRandGen;

/**
 * RecurseNT mutator.
 * 
 * Anade un nuevo nivel de recursividad insertando una produccion
 * de algun simbolo no terminal recursivo dentro de una rama
 * derivada del mimo simbolo.
 * 
 * @author Amelia Zafra

 */

public class RecurseNTMutator implements IMutateSyntaxTree 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -2706522794304044852L;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public RecurseNTMutator() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------- Implementing IConfigure interface
	/////////////////////////////////////////////////////////////////
	
	// java.lang.Object methods 

	public boolean equals(Object other)
	{
		if (other instanceof RecurseNTMutator) {
			return true;
		}
		else {
			return false;
		}
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	@Override
	public SyntaxTree mutateSyntaxTree(SyntaxTree parent, SyntaxTreeSchema schema, IRandGen randgen)	
	{	
		// Son genotype
		SyntaxTree son = new SyntaxTree(); 
		// Select a recursive non terminal symbol 
		int p0_branchStart = selectSymbol(parent, schema, randgen); 
		// If a recursive non terminal symbol doesn't exist in tree, copy parents and return 
		if (p0_branchStart == -1) {
			for(int i=0; i<parent.size(); i++)	son.addNode(parent.getNode(i).copy());			
			return son;
		}
		
		// Obtain a recursive derivation of the selected symbol
		NonTerminalNode selectedProduction = 
			chooseRecursiveProduction(parent.getNode(p0_branchStart).getSymbol(), schema, randgen);
		
		// Set branch end 
		int p0_branchEnd = parent.subTree(p0_branchStart);
		
		// Fist fragment of the son
		for (int i=0; i<p0_branchStart; i++) son.addNode(parent.getNode(i).copy());
		
		// Add the new recursive production
		addProduction(parent, son, selectedProduction, p0_branchStart, p0_branchEnd, schema, randgen);

		// Last fragment of the son
		for(int j=p0_branchEnd; j<parent.size(); j++)
			son.addNode(parent.getNode(j).copy());
	
		// If it is not a valid individual, copy and return the parent
		if (son.derivSize() > schema.getMaxDerivSize()) {
			son.clear();
			for(int i=0; i<parent.size(); i++) 
				son.addNode(parent.getNode(i).copy());
		}
		
		// Return son
		return son;
	}	
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Seleccionar un simbolo no terminal que sea recursivo.
	 * 
	 * @param tree Arbol donde selecionar el simbolo no terminal
	 * 
	 * @return Localizacion del simbolo seleccionado
	 */
	
	private final int selectSymbol(SyntaxTree tree, SyntaxTreeSchema schema, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		// 
		int actPos = startPos;
		for(int i=0; i<treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
		
			if( !schema.isTerminal(tree.getNode(actPos).getSymbol()) ) {
				// Check if it is a recursive symbol
				NonTerminalNode nonTerminalSymbols = (NonTerminalNode) tree.getNode(actPos);
				
				for (int j=0; j<nonTerminalSymbols.getProduction().length; j++){
					if(tree.getNode(actPos).getSymbol().equalsIgnoreCase(nonTerminalSymbols.getProduction()[j])) {
						//Search the recursive symbol in the parent
						for(int p=actPos+1; p<tree.size(); p++ ) {
							if(tree.getNode(p).getSymbol().equalsIgnoreCase(nonTerminalSymbols.getProduction()[j])) {
								return p;							
							}
						}
					}
				}
			}
		}
		
		return -1;
		
	}
	
	public void addProduction(SyntaxTree parent, SyntaxTree son, NonTerminalNode selectedProduction, int initialPoint, int finalPoint, SyntaxTreeSchema schema, IRandGen randgen)
	{
		// Add this node
		son.addNode(selectedProduction);
		
		boolean visited = false;
		int selProdSize = selectedProduction.getProduction().length;
		for (int i=0; i<selProdSize; i++) {
			
			// If it is the same symbol, copy the branch of the parent
			if(selectedProduction.getProduction()[i].equalsIgnoreCase(selectedProduction.getSymbol()) && visited == false){
				visited = true;
				int endBranch = parent.subTree(initialPoint);
				for(int h=initialPoint; h<endBranch; h++)
						son.addNode(parent.getNode(h).copy());
			}
			else{
				schema.fillSyntaxBranch(son, selectedProduction.getProduction()[i], randgen);
			}
		}
	}
	
	public NonTerminalNode chooseRecursiveProduction(String selectedSymbol, SyntaxTreeSchema schema, IRandGen randgen){
		
		NonTerminalNode [] nonTerminalNodes = schema.getNonTerminals();
		List<NonTerminalNode> recursiveNonTerminalNodes = new ArrayList<NonTerminalNode>();
		
		boolean recursive = false;
		// Search recursive productions for selected symbol
		for(int h=0; h<nonTerminalNodes.length; h++) 
		{
			if(nonTerminalNodes[h].getSymbol().equalsIgnoreCase(selectedSymbol))
			{
				recursive = false;
				for (int j=0; j<nonTerminalNodes[h].getProduction().length && recursive == false; j++)
				{
					if(selectedSymbol.equalsIgnoreCase(nonTerminalNodes[h].getProduction()[j]))
					{
						recursive = true;
						// Add No Recursive Production
						recursiveNonTerminalNodes.add(nonTerminalNodes[h]);	
					}
				}					
			}
		}
		
		//Choose randomly one production
		int nOfProduction = randgen.choose(0, recursiveNonTerminalNodes.size()-1);
		return recursiveNonTerminalNodes.get(nOfProduction);
	}
}
