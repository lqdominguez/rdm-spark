package net.sf.jclec.syntaxtree.mut;

import net.sf.jclec.util.random.IRandGen;

import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.syntaxtree.IMutateSyntaxTree;

/**
 * UnRecurseNT mutator.
 * 
 * Elimina de una rama generada de forma recursiva, una de las
 * producciones causanets de dicha rama y utiliza las ramas 
 * inferiores para reconstruir el arbol.
 * 
 * @author Amelia Zafra
 */


public class UnRecurseNTMutator implements IMutateSyntaxTree 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -2706522794304044852L;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public UnRecurseNTMutator() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	// java.lang.Object methods

	public boolean equals(Object other)
	{
		if (other instanceof UnRecurseNTMutator) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////	
	
	@Override
	public SyntaxTree mutateSyntaxTree(SyntaxTree parent, SyntaxTreeSchema schema, IRandGen randgen)	
	{	
		// Son genotype
		SyntaxTree son = new SyntaxTree(); 
		
		// Select a recursive no terminal symbol 
		int p0_branchStart = selectSymbol(parent, schema, randgen);
		
		// If a no recursive symbol doesn't exist in tree, copy parents and return 
		if (p0_branchStart == -1) {
			for(int i=0; i<parent.size(); i++)	
				son.addNode(parent.getNode(i).copy());	
			return son;
		}
		
		// Assign the selected symbol
		NonTerminalNode selectedSymbol = (NonTerminalNode) parent.getNode(p0_branchStart);
		
		// Set branch end 
		int p0_branchEnd = parent.subTree(p0_branchStart);
		
		// Create son (first fragment)
		for (int i=0; i<p0_branchStart; i++) son.addNode(parent.getNode(i).copy());

		// Create son (second fragment)
		boolean visited = false;
		for(int i=p0_branchStart+1; i<p0_branchEnd && visited == false; i++ ){
			if(parent.getNode(i).getSymbol().equalsIgnoreCase(selectedSymbol.getSymbol())){
				visited = true;				
				// Complete the branch
				int branchEnd = parent.subTree(i);
				for(int j = i; j<branchEnd; j++) 
					son.addNode(parent.getNode(j).copy());
			}
		}
			
		// Create son (last fragment)
		for(int i=p0_branchEnd; i<parent.size(); i++)	
			son.addNode(parent.getNode(i).copy());
		
		// Return son
		return son;

	}	
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Seleccionar un simbolo no terminal recursivo del arbol.
	 * 
	 * @param tree Arbol donde selecionar un simbolo.
	 * 
	 * @return Localizacion del simbolo seleccionado.
	 */
	
	private final int selectSymbol(SyntaxTree tree, SyntaxTreeSchema schema, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		// 
		int actPos = startPos;
		for(int i=0; i<treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
		
			if(! schema.isTerminal(tree.getNode(actPos).getSymbol()) ){				
				// Check if it is a recursive symbol
				NonTerminalNode nonTerminalSymbols = (NonTerminalNode) tree.getNode(actPos);
				for(int j=0; j<nonTerminalSymbols.getProduction().length; j++)
				{
					if(tree.getNode(actPos).getSymbol().equalsIgnoreCase(nonTerminalSymbols.getProduction()[j]))
					{
						return actPos;
					}
				}
			}
		}		
		return -1;
	}	
}
