package net.sf.jclec.syntaxtree;

import net.sf.jclec.IConfigure;
import net.sf.jclec.exprtree.IPrimitive;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Species for SyntaxTreeIndividual.
 * 
 * @author Sebastian Ventura
 */

public class SyntaxTreeIndividualSpecies extends SyntaxTreeSpecies implements IConfigure 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -5659464424179862147L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	public SyntaxTreeIndividualSpecies() 
	{
		super();
		genotypeSchema = new SyntaxTreeSchema();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------- Setting and getting properties
	/////////////////////////////////////////////////////////////////

	// Setting properties
	
	/**
	 * Set the name of the root symbol 
	 * 
	 * @param rootSymbolName Root symbol name
	 */
	
	public void setRootSymbol(String rootSymbolName)
	{
		genotypeSchema.setRootSymbol(rootSymbolName);
	}
		
	/**
	 * Set terminal symbols for this grammar.
	 * 
	 * @param terminals Terminal symbols
	 */
		
	public void setTerminals(TerminalNode [] terminals)
	{
		genotypeSchema.setTerminals(terminals);
	}
		
	/**
	 * Set non-terminal symbols for this grammar.
	 * 
	 * @param nonTerminals Nonterminal symbols
	 */
		
	public void setNonTerminals(NonTerminalNode [] nonTerminals)
	{
		genotypeSchema.setNonTerminals(nonTerminals);
	}
		
	/**
	 * Set the maximum derivation size for this schema.
	 * 
	 * @param maxDerivSize Maximum of derivations 
	 */
		
	public void setMaxDerivSize(int maxDerivSize) 
	{
		genotypeSchema.setMaxDerivSize(maxDerivSize);
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------- Implementing ISyntaxTreeSpecies methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Creates a SyntaxTreeIndividual
	 * 
	 * @return new SyntaxTreeIndividual individual
	 */
	
	public SyntaxTreeIndividual createIndividual() 
	{
		return new SyntaxTreeIndividual();
	}

	/**
	 * {@inheritDoc}
	 */
	
	public SyntaxTreeIndividual createIndividual(SyntaxTree genotype) 
	{
		return new SyntaxTreeIndividual(genotype);
	}

	/**
	 * Configuration method.
	 * 
	 * Configuration parameters for this species are...
	 * 
	 */
		
	@SuppressWarnings("unchecked")
	public void configure(Configuration settings) 
	{
		// Get terminal symbols
		int numberOfTermSymbols = 
			settings.getList("terminal-symbols.symbol.name").size();
		TerminalNode [] terminals = 
				new TerminalNode[numberOfTermSymbols]; 
		for (int j=0; j<numberOfTermSymbols; j++) {
			TerminalNode termSymbol = new TerminalNode();
			// Symbol name
			termSymbol.symbol = 
				settings.getString("terminal-symbols.symbol("+j+")"+".name");
			// Symbol code
			try {
				String termSymbolCodeClassname = 
					settings.getString("terminal-symbols.symbol("+j+")"+".code");
				Class<? extends IPrimitive> termSymbolCodeClass = 
					(Class<? extends IPrimitive>) Class.forName(termSymbolCodeClassname);
				termSymbol.code = termSymbolCodeClass.newInstance();
			} 
			catch (ClassNotFoundException e) {
				e.printStackTrace();
			} 
			catch (InstantiationException e) {
				e.printStackTrace();
			} 
			catch (IllegalAccessException e) {
				e.printStackTrace();
			}
			// Set array element
			terminals[j] = termSymbol;
		}
		// Set terminal symbols for i-th tree
		setTerminals(terminals);
		// Get non-terminal symbols
		int numberOfNonTermSymbols = 
			settings.getList("non-terminal-symbols.symbol.name").size();
		NonTerminalNode [] nonTermSymbols = 
			new NonTerminalNode[numberOfNonTermSymbols];
		for (int j=0; j<numberOfNonTermSymbols; j++) {
			NonTerminalNode nonTermSymbol = new NonTerminalNode();
			// Symbol name
			nonTermSymbol.symbol = 
				settings.getString("non-terminal-symbols.symbol("+j+")"+".name");
			// Symbol production
			nonTermSymbol.production = (String [])
				settings.getList("non-terminal-symbols.symbol("+j+")"+".production-rule.element").toArray(new String[0]);				
			// Set array element
			nonTermSymbols[j] = nonTermSymbol;
		}			
		setNonTerminals(nonTermSymbols);
		// Get root-symbol
		String rootSymbol = settings.getString("root-symbol");
		setRootSymbol(rootSymbol);
		// Get max-tree-depth
		int maxDerivSize = settings.getInt("max-deriv-size");
		setMaxDerivSize(maxDerivSize);
	}
	
	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting java.lang.Object methods
	/////////////////////////////////////////////////////////////////
	
	public boolean equals(Object other)
	{
		if (other instanceof SyntaxTreeIndividualSpecies) {
			// Type conversion
			SyntaxTreeIndividualSpecies cother = (SyntaxTreeIndividualSpecies) other;
			// Performs comparison
			EqualsBuilder eb = new EqualsBuilder();
			eb.append(genotypeSchema, cother.genotypeSchema);
			// Return comparison result
			return eb.isEquals();
		}
		else {
			return false;
		}
	}
}
