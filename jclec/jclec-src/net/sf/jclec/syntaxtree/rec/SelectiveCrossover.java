package net.sf.jclec.syntaxtree.rec;

import java.util.Comparator;

import net.sf.jclec.IConfigure;

import net.sf.jclec.util.random.IRandGen;

import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeNode;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.syntaxtree.IRecombineSyntaxTree;


import org.apache.commons.configuration.Configuration;
import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Selective crossover.
 * 
 * @author Sebastian Ventura
 * @author Amelia Zafra 
 */

public class SelectiveCrossover implements IRecombineSyntaxTree, IConfigure 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -6447244450691681809L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Maximum derivation size for the sons created */
	
	protected int maximumDerivSize;
	
	/** Symbols in this crossover operation */

	protected NonTerminalNode [] selectedSymbols;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////

	/** Used to compare symbols */
	
	protected transient Comparator<SyntaxTreeNode> symbolsComparator = new Comparator<SyntaxTreeNode> ()
	{
		public int compare(SyntaxTreeNode o1, SyntaxTreeNode o2) 
		{			
			if (o1 instanceof NonTerminalNode && o2 instanceof NonTerminalNode) {
				NonTerminalNode co1 = (NonTerminalNode) o1;
				NonTerminalNode co2 = (NonTerminalNode) o2;
				EqualsBuilder eb = new EqualsBuilder();
				eb.append(co1.getSymbol(), co2.getSymbol());
				
				if(eb.isEquals())
					return 0;
				else
					return -1;
			}
			return -1;
		}	
	};	
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public SelectiveCrossover() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// Getting and setting properties

	public NonTerminalNode[] getSelectedSymbols() 
	{
		return selectedSymbols;
	}

	public void setSelectedSymbols(NonTerminalNode[] selectedSymbols) 
	{
		this.selectedSymbols = selectedSymbols;
	}
	
	// Implementing IConfigure interface
	
	public void configure (Configuration settings)
	{
		// get number of selected symbols in grammar
		int selSymDimension = settings.getInt("selected-symbols[@selected-dimension]", 0);
		if (selSymDimension != 0) {
			//allocate space for selectedSymbols
			selectedSymbols = new NonTerminalNode[selSymDimension];
			//Get all terminalSymbol elements
			for ( int i =0; i < selSymDimension; i++)
			{
				//create Selected Symbol
				NonTerminalNode element = new NonTerminalNode ();
				//configuration header
				String header = "selected-symbols.dimension("+i+")";
				//Selected Symbol name
				String selName = settings.getString(header + ".name");
				//set Element name
				element.setSymbol(selName);
				selectedSymbols[i] = element;
			}
			setSelectedSymbols(selectedSymbols);
		}
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	/**
	 * This operator performs the following operations:
	 * 
	 * <ol>
	 * <li>Select a non terminal symbol at random (NT)</li>
	 * <li>Search NT in first parent</li> 
	 * </ol>
	 */
	@Override
	public void recombine(SyntaxTree ptree0, SyntaxTree ptree1, SyntaxTree stree0, SyntaxTree stree1, SyntaxTreeSchema schema, IRandGen randgen) 
	{
		if(selectedSymbols == null){
			selectedSymbols = schema.getNonTerminals();
		}		
		// Set selected symbol 
		int numberOfSelectedSymbols = selectedSymbols.length;
		NonTerminalNode selectedSymbol = 
			selectedSymbols[randgen.choose(0, numberOfSelectedSymbols)];
		// Search selected symbol in first parent
		int p0_branchStart = searchSymbolIn(selectedSymbol, ptree0, randgen);
		// If symbol don't exist in tree, copy parents and return 
		if (p0_branchStart == -1) {
			// Copy parents genotypes
			for(int i=0; i<ptree0.size(); i++) {
				stree0.addNode(ptree0.getNode(i).copy());
			}
			for(int i=0; i<ptree1.size(); i++) {
				stree1.addNode(ptree1.getNode(i).copy());
			}
			return;
		}		
		// Set branch end 
		int	p0_branchEnd = ptree0.subTree(p0_branchStart);
		// Set branch depth (to check maximum size)
		int p0_branchDepth = ptree0.derivSize();
		int p0_swapBranch = 0;
		for(int i=p0_branchStart; i<p0_branchEnd; i++){
			if(ptree0.getNode(i).arity()!=0)
				p0_swapBranch ++;
		}		
		// Search selected symbol in second parent
		int p1_branchStart = searchSymbolIn(selectedSymbol, ptree1, randgen);
		// If symbol don't exist in tree, copy parents and return 
		if (p1_branchStart == -1) {
			// Copy parents genotypes
			for(int i=0; i<ptree0.size(); i++)
				stree0.addNode(ptree0.getNode(i).copy());
			for(int i=0; i<ptree1.size(); i++)
				stree1.addNode(ptree1.getNode(i).copy());					
			return;
		}
		// Set branch end 
		int p1_branchEnd = ptree1.subTree(p1_branchStart);
		// Set branch depth (to check maximum size)
		int p1_branchDepth = ptree1.derivSize();
		int p1_swapBranch = 0;
		for(int i=p1_branchStart; i<p1_branchEnd; i++){
			if(ptree1.getNode(i).arity()!=0)
				p1_swapBranch ++;
		}
	
		// Check maxTreeDepth condition
		int maxDerivSize = schema.getMaxDerivSize();
		boolean cond0 = (p0_branchDepth - p0_swapBranch + p1_swapBranch > maxDerivSize);
		boolean cond1 = (p1_branchDepth - p1_swapBranch + p0_swapBranch > maxDerivSize);
		if (cond0 || cond1) {
			// Copy parents genotypes
			for(int i=0; i<ptree0.size(); i++)
				stree0.addNode(ptree0.getNode(i));
			
			for(int i=0; i<ptree1.size(); i++)
				stree1.addNode(ptree1.getNode(i));
			
			return;			
		}
		// Perform crossover operation (first fragment)
		for (int i=0; i<p0_branchStart; i++) 
			stree0.addNode(ptree0.getNode(i).copy());
		for (int i=0; i<p1_branchStart; i++) 
			stree1.addNode(ptree1.getNode(i).copy());
		
		// Perform crossover operation (second fragment)
		for (int i=p0_branchStart; i<p0_branchEnd; i++) {
			// Create node
			SyntaxTreeNode node = ptree0.getNode(i).copy();
			// Add updated node
			stree1.addNode(node);			
		}
		for (int i=p1_branchStart; i<p1_branchEnd; i++) {
			// Create node			
			SyntaxTreeNode node = ptree1.getNode(i).copy();
			// Add updated node
			stree0.addNode(node);			
		}
		// Perform crossover operation (third fragment)
		int p0_length = ptree0.size();
		for (int i=p0_branchEnd; i<p0_length; i++) 
			stree0.addNode(ptree0.getNode(i).copy());
		int p1_length = ptree1.size();
		for (int i=p1_branchEnd; i<p1_length; i++) 
			stree1.addNode(ptree1.getNode(i).copy());
	}
		
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	private final int searchSymbolIn(NonTerminalNode symbol, SyntaxTree tree, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		// 
		int actPos = startPos;
		for(int i=0; i<treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
			// Check symbols equality
			if(symbolsComparator.compare(symbol, tree.getNode(actPos)) == 0)
				return actPos;
		}		 
		return -1;
	}
}
