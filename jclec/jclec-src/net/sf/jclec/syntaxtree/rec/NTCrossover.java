package net.sf.jclec.syntaxtree.rec;

import java.util.Comparator;

import net.sf.jclec.util.random.IRandGen;

import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeNode;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.IRecombineSyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * NT crossover. 
 * 
 * Realiza un intercambio entre i?oerboles de ramas derivadas del mismo si?oembolo no 
 * terminal. 
 * 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class NTCrossover implements IRecombineSyntaxTree 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -6447244450691681809L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////
	
	/** Used to compare symbols */
	
	protected transient Comparator<SyntaxTreeNode> symbolsComparator = new Comparator<SyntaxTreeNode> () 
	{
		public int compare(SyntaxTreeNode o1, SyntaxTreeNode o2) 
		{			
			if (o1 instanceof NonTerminalNode && o2 instanceof NonTerminalNode) {
				NonTerminalNode co1 = (NonTerminalNode) o1;
				NonTerminalNode co2 = (NonTerminalNode) o2;
				EqualsBuilder eb = new EqualsBuilder();
				eb.append(co1.getSymbol(), co2.getSymbol());
				
				if(eb.isEquals())
					return 0;
				else
					return -1;
			}
			return -1;
		}	
	};
		
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public NTCrossover() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// java.lang.Object methods

	public boolean equals(Object other)
	{
		if (other instanceof NTCrossover) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	// SyntaxTreeRecombinator methods
	
	@Override
	public void recombine(SyntaxTree ptree0, SyntaxTree tree1, SyntaxTree stree0, SyntaxTree stree1, SyntaxTreeSchema schema, IRandGen randgen) 
	{
		// Search a non terminal symbol in first parent
		int p0_branchStart = selectSymbol(ptree0, tree1, schema, randgen);
		// If a no terminal symbol don't exist in tree, or there is not a 
		// two same symbols in the two parents, copy the parents and return 
		if (p0_branchStart == -1) {
			// Copy parents genotypes
			for(int i=0; i<ptree0.size(); i++)
				stree0.addNode(ptree0.getNode(i));
			for(int i=0; i<tree1.size(); i++)
				stree1.addNode(tree1.getNode(i));
			return;
		}
		// Symbol to select
		NonTerminalNode selectedSymbol = 
			(NonTerminalNode) ptree0.getNode(p0_branchStart) ;
		// Search selected symbol in second parent
		int p1_branchStart = searchSymbolIn(selectedSymbol, tree1, randgen);
		// Set branch end 
		int	p0_branchEnd = ptree0.subTree(p0_branchStart);
		int p1_branchEnd = tree1.subTree(p1_branchStart);
		// Set branch depth (to check maximum size)
		int p0_branchDepth = ptree0.derivSize();
		int p0_swapBranch = 0;
		for(int i=p0_branchStart; i<p0_branchEnd; i++){
			if(ptree0.getNode(i).arity()!=0)
				p0_swapBranch ++;
		}		
		// Set branch depth (to check maximum size)
		int p1_branchDepth = tree1.derivSize();
		int p1_swapBranch = 0;
		for(int i=p1_branchStart; i<p1_branchEnd; i++){
			if(tree1.getNode(i).arity()!=0)
				p1_swapBranch ++;
		}	
		// Check maxTreeDepth condition
		int maxDerivSize = schema.getMaxDerivSize();
		boolean cond0 = (p0_branchDepth - p0_swapBranch + p1_swapBranch > maxDerivSize);
		boolean cond1 = (p1_branchDepth - p1_swapBranch + p0_swapBranch > maxDerivSize);
		if (cond0 || cond1) {
			// Copy parents genotypes
			for(int i=0; i<ptree0.size(); i++)
				stree0.addNode(ptree0.getNode(i));			
			for(int i=0; i<tree1.size(); i++)
				stree1.addNode(tree1.getNode(i));
			return;			
		}		
		// Perform crossover operation (first fragment)
		for (int i=0; i<p0_branchStart; i++) 
			stree0.addNode(ptree0.getNode(i).copy());
		for (int i=0; i<p1_branchStart; i++) 
			stree1.addNode(tree1.getNode(i).copy());		
		// Perform crossover operation (second fragment)
		for (int i=p0_branchStart; i<p0_branchEnd; i++) 
			stree1.addNode(ptree0.getNode(i).copy());			
		for (int i=p1_branchStart; i<p1_branchEnd; i++) 
			stree0.addNode(tree1.getNode(i).copy());		
		// Perform crossover operation (third fragment)
		int p0_length = ptree0.size();
		for (int i=p0_branchEnd; i<p0_length; i++) 
			stree0.addNode(ptree0.getNode(i).copy());
		int p1_length = tree1.size();
		for (int i=p1_branchEnd; i<p1_length; i++) 
			stree1.addNode(tree1.getNode(i).copy());	
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Seleccionar un si?oembolo no terminal cualquiera del arbol, y comprobar
	 * que dicho si?oembolo tambii?oen lo posea el otro padre.
	 * 
	 * @param tree0 Arbol donde selecionar un si?oembolo cualquiera
	 * @param tree1 Arbol del segundo padre para comprobar que el si?oembolo
	 * 				exista para que sea el seleccionado
	 * 
	 * @return Localizacii?oen del si?oembolo seleccionado
	 */

	private final int selectSymbol(SyntaxTree tree0, SyntaxTree tree1, SyntaxTreeSchema schema, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree0.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		
		int actPos = startPos;
		for(int i=0; i<treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
			// Check symbol is nontermianl
			if( !schema.isTerminal(tree0.getNode(actPos).getSymbol()) )
				// Check if this symbol exists int the other parent
				if(searchSymbolIn((NonTerminalNode) tree0.getNode(actPos), tree1, randgen) != -1)
					return actPos;				
		}				
		return -1;
	}
	
	private final int searchSymbolIn(NonTerminalNode symbol, SyntaxTree tree, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		// 
		int actPos = startPos;
		for(int i=0; i<treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
			// Check symbols equality
			if(symbolsComparator.compare(symbol, tree.getNode(actPos)) == 0)
				return actPos;
		}		
		return -1;
	}
}
